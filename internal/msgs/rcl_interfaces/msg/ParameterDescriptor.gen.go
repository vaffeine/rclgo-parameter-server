// Code generated by rclgo-gen. DO NOT EDIT.

package rcl_interfaces_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	primitives "github.com/tiiuae/rclgo/pkg/rclgo/primitives"
	
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <rcl_interfaces/msg/parameter_descriptor.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("rcl_interfaces/ParameterDescriptor", ParameterDescriptorTypeSupport)
	typemap.RegisterMessage("rcl_interfaces/msg/ParameterDescriptor", ParameterDescriptorTypeSupport)
}

type ParameterDescriptor struct {
	Name string `yaml:"name"`// The name of the parameter.
	Type uint8 `yaml:"type"`// Enum values are defined in the `ParameterType.msg` message.
	Description string `yaml:"description"`// Description of the parameter, visible from introspection tools.
	AdditionalConstraints string `yaml:"additional_constraints"`// Plain English description of additional constraints which cannot be expressedwith the available constraints, e.g. "only prime numbers".By convention, this should only be used to clarify constraints which cannotbe completely expressed with the parameter constraints below.
	ReadOnly bool `yaml:"read_only"`// If 'true' then the value cannot change after it has been initialized.
	DynamicTyping bool `yaml:"dynamic_typing"`// If true, the parameter is allowed to change type.
	FloatingPointRange []FloatingPointRange `yaml:"floating_point_range"`// FloatingPointRange consists of a from_value, a to_value, and a step.
	IntegerRange []IntegerRange `yaml:"integer_range"`// IntegerRange consists of a from_value, a to_value, and a step.
}

// NewParameterDescriptor creates a new ParameterDescriptor with default values.
func NewParameterDescriptor() *ParameterDescriptor {
	self := ParameterDescriptor{}
	self.SetDefaults()
	return &self
}

func (t *ParameterDescriptor) Clone() *ParameterDescriptor {
	c := &ParameterDescriptor{}
	c.Name = t.Name
	c.Type = t.Type
	c.Description = t.Description
	c.AdditionalConstraints = t.AdditionalConstraints
	c.ReadOnly = t.ReadOnly
	c.DynamicTyping = t.DynamicTyping
	if t.FloatingPointRange != nil {
		c.FloatingPointRange = make([]FloatingPointRange, len(t.FloatingPointRange))
		CloneFloatingPointRangeSlice(c.FloatingPointRange, t.FloatingPointRange)
	}
	if t.IntegerRange != nil {
		c.IntegerRange = make([]IntegerRange, len(t.IntegerRange))
		CloneIntegerRangeSlice(c.IntegerRange, t.IntegerRange)
	}
	return c
}

func (t *ParameterDescriptor) CloneMsg() types.Message {
	return t.Clone()
}

func (t *ParameterDescriptor) SetDefaults() {
	t.Name = ""
	t.Type = 0
	t.Description = ""
	t.AdditionalConstraints = ""
	t.ReadOnly = false
	t.DynamicTyping = false
	t.FloatingPointRange = nil
	t.IntegerRange = nil
}

func (t *ParameterDescriptor) GetTypeSupport() types.MessageTypeSupport {
	return ParameterDescriptorTypeSupport
}

// ParameterDescriptorPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type ParameterDescriptorPublisher struct {
	*rclgo.Publisher
}

// NewParameterDescriptorPublisher creates and returns a new publisher for the
// ParameterDescriptor
func NewParameterDescriptorPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*ParameterDescriptorPublisher, error) {
	pub, err := node.NewPublisher(topic_name, ParameterDescriptorTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &ParameterDescriptorPublisher{pub}, nil
}

func (p *ParameterDescriptorPublisher) Publish(msg *ParameterDescriptor) error {
	return p.Publisher.Publish(msg)
}

// ParameterDescriptorSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type ParameterDescriptorSubscription struct {
	*rclgo.Subscription
}

// ParameterDescriptorSubscriptionCallback type is used to provide a subscription
// handler function for a ParameterDescriptorSubscription.
type ParameterDescriptorSubscriptionCallback func(msg *ParameterDescriptor, info *rclgo.MessageInfo, err error)

// NewParameterDescriptorSubscription creates and returns a new subscription for the
// ParameterDescriptor
func NewParameterDescriptorSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback ParameterDescriptorSubscriptionCallback) (*ParameterDescriptorSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg ParameterDescriptor
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, ParameterDescriptorTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &ParameterDescriptorSubscription{sub}, nil
}

func (s *ParameterDescriptorSubscription) TakeMessage(out *ParameterDescriptor) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneParameterDescriptorSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneParameterDescriptorSlice(dst, src []ParameterDescriptor) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var ParameterDescriptorTypeSupport types.MessageTypeSupport = _ParameterDescriptorTypeSupport{}

type _ParameterDescriptorTypeSupport struct{}

func (t _ParameterDescriptorTypeSupport) New() types.Message {
	return NewParameterDescriptor()
}

func (t _ParameterDescriptorTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.rcl_interfaces__msg__ParameterDescriptor
	return (unsafe.Pointer)(C.rcl_interfaces__msg__ParameterDescriptor__create())
}

func (t _ParameterDescriptorTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.rcl_interfaces__msg__ParameterDescriptor__destroy((*C.rcl_interfaces__msg__ParameterDescriptor)(pointer_to_free))
}

func (t _ParameterDescriptorTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*ParameterDescriptor)
	mem := (*C.rcl_interfaces__msg__ParameterDescriptor)(dst)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.name), m.Name)
	mem._type = C.uint8_t(m.Type)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.description), m.Description)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.additional_constraints), m.AdditionalConstraints)
	mem.read_only = C.bool(m.ReadOnly)
	mem.dynamic_typing = C.bool(m.DynamicTyping)
	FloatingPointRange__Sequence_to_C(&mem.floating_point_range, m.FloatingPointRange)
	IntegerRange__Sequence_to_C(&mem.integer_range, m.IntegerRange)
}

func (t _ParameterDescriptorTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*ParameterDescriptor)
	mem := (*C.rcl_interfaces__msg__ParameterDescriptor)(ros2_message_buffer)
	primitives.StringAsGoStruct(&m.Name, unsafe.Pointer(&mem.name))
	m.Type = uint8(mem._type)
	primitives.StringAsGoStruct(&m.Description, unsafe.Pointer(&mem.description))
	primitives.StringAsGoStruct(&m.AdditionalConstraints, unsafe.Pointer(&mem.additional_constraints))
	m.ReadOnly = bool(mem.read_only)
	m.DynamicTyping = bool(mem.dynamic_typing)
	FloatingPointRange__Sequence_to_Go(&m.FloatingPointRange, mem.floating_point_range)
	IntegerRange__Sequence_to_Go(&m.IntegerRange, mem.integer_range)
}

func (t _ParameterDescriptorTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__rcl_interfaces__msg__ParameterDescriptor())
}

type CParameterDescriptor = C.rcl_interfaces__msg__ParameterDescriptor
type CParameterDescriptor__Sequence = C.rcl_interfaces__msg__ParameterDescriptor__Sequence

func ParameterDescriptor__Sequence_to_Go(goSlice *[]ParameterDescriptor, cSlice CParameterDescriptor__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]ParameterDescriptor, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		ParameterDescriptorTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func ParameterDescriptor__Sequence_to_C(cSlice *CParameterDescriptor__Sequence, goSlice []ParameterDescriptor) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.rcl_interfaces__msg__ParameterDescriptor)(C.malloc(C.sizeof_struct_rcl_interfaces__msg__ParameterDescriptor * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		ParameterDescriptorTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func ParameterDescriptor__Array_to_Go(goSlice []ParameterDescriptor, cSlice []CParameterDescriptor) {
	for i := 0; i < len(cSlice); i++ {
		ParameterDescriptorTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func ParameterDescriptor__Array_to_C(cSlice []CParameterDescriptor, goSlice []ParameterDescriptor) {
	for i := 0; i < len(goSlice); i++ {
		ParameterDescriptorTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
