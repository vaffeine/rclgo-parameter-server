// Code generated by rclgo-gen. DO NOT EDIT.

package rcl_interfaces_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <rcl_interfaces/msg/floating_point_range.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("rcl_interfaces/FloatingPointRange", FloatingPointRangeTypeSupport)
	typemap.RegisterMessage("rcl_interfaces/msg/FloatingPointRange", FloatingPointRangeTypeSupport)
}

type FloatingPointRange struct {
	FromValue float64 `yaml:"from_value"`// Start value for valid values, inclusive.
	ToValue float64 `yaml:"to_value"`// End value for valid values, inclusive.
	Step float64 `yaml:"step"`// Size of valid steps between the from and to bound.Step is considered to be a magnitude, therefore negative values are treatedthe same as positive values, and a step value of zero implies a continuousrange of values.Ideally, the step would be less than or equal to the distance between thebounds, as well as an even multiple of the distance between the bounds, butneither are required.If the absolute value of the step is larger than or equal to the distancebetween the two bounds, then the bounds will be the only valid values. e.g. ifthe range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then thevalid values will be 1.0 and 2.0.If the step is less than the distance between the bounds, but the distance isnot a multiple of the step, then the "to" bound will always be a valid value,e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}then the valid values will be 2.0, 4.0, and 5.0.
}

// NewFloatingPointRange creates a new FloatingPointRange with default values.
func NewFloatingPointRange() *FloatingPointRange {
	self := FloatingPointRange{}
	self.SetDefaults()
	return &self
}

func (t *FloatingPointRange) Clone() *FloatingPointRange {
	c := &FloatingPointRange{}
	c.FromValue = t.FromValue
	c.ToValue = t.ToValue
	c.Step = t.Step
	return c
}

func (t *FloatingPointRange) CloneMsg() types.Message {
	return t.Clone()
}

func (t *FloatingPointRange) SetDefaults() {
	t.FromValue = 0
	t.ToValue = 0
	t.Step = 0
}

func (t *FloatingPointRange) GetTypeSupport() types.MessageTypeSupport {
	return FloatingPointRangeTypeSupport
}

// FloatingPointRangePublisher wraps rclgo.Publisher to provide type safe helper
// functions
type FloatingPointRangePublisher struct {
	*rclgo.Publisher
}

// NewFloatingPointRangePublisher creates and returns a new publisher for the
// FloatingPointRange
func NewFloatingPointRangePublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*FloatingPointRangePublisher, error) {
	pub, err := node.NewPublisher(topic_name, FloatingPointRangeTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &FloatingPointRangePublisher{pub}, nil
}

func (p *FloatingPointRangePublisher) Publish(msg *FloatingPointRange) error {
	return p.Publisher.Publish(msg)
}

// FloatingPointRangeSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type FloatingPointRangeSubscription struct {
	*rclgo.Subscription
}

// FloatingPointRangeSubscriptionCallback type is used to provide a subscription
// handler function for a FloatingPointRangeSubscription.
type FloatingPointRangeSubscriptionCallback func(msg *FloatingPointRange, info *rclgo.MessageInfo, err error)

// NewFloatingPointRangeSubscription creates and returns a new subscription for the
// FloatingPointRange
func NewFloatingPointRangeSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback FloatingPointRangeSubscriptionCallback) (*FloatingPointRangeSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg FloatingPointRange
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, FloatingPointRangeTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &FloatingPointRangeSubscription{sub}, nil
}

func (s *FloatingPointRangeSubscription) TakeMessage(out *FloatingPointRange) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneFloatingPointRangeSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneFloatingPointRangeSlice(dst, src []FloatingPointRange) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var FloatingPointRangeTypeSupport types.MessageTypeSupport = _FloatingPointRangeTypeSupport{}

type _FloatingPointRangeTypeSupport struct{}

func (t _FloatingPointRangeTypeSupport) New() types.Message {
	return NewFloatingPointRange()
}

func (t _FloatingPointRangeTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.rcl_interfaces__msg__FloatingPointRange
	return (unsafe.Pointer)(C.rcl_interfaces__msg__FloatingPointRange__create())
}

func (t _FloatingPointRangeTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.rcl_interfaces__msg__FloatingPointRange__destroy((*C.rcl_interfaces__msg__FloatingPointRange)(pointer_to_free))
}

func (t _FloatingPointRangeTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*FloatingPointRange)
	mem := (*C.rcl_interfaces__msg__FloatingPointRange)(dst)
	mem.from_value = C.double(m.FromValue)
	mem.to_value = C.double(m.ToValue)
	mem.step = C.double(m.Step)
}

func (t _FloatingPointRangeTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*FloatingPointRange)
	mem := (*C.rcl_interfaces__msg__FloatingPointRange)(ros2_message_buffer)
	m.FromValue = float64(mem.from_value)
	m.ToValue = float64(mem.to_value)
	m.Step = float64(mem.step)
}

func (t _FloatingPointRangeTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__rcl_interfaces__msg__FloatingPointRange())
}

type CFloatingPointRange = C.rcl_interfaces__msg__FloatingPointRange
type CFloatingPointRange__Sequence = C.rcl_interfaces__msg__FloatingPointRange__Sequence

func FloatingPointRange__Sequence_to_Go(goSlice *[]FloatingPointRange, cSlice CFloatingPointRange__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]FloatingPointRange, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		FloatingPointRangeTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func FloatingPointRange__Sequence_to_C(cSlice *CFloatingPointRange__Sequence, goSlice []FloatingPointRange) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.rcl_interfaces__msg__FloatingPointRange)(C.malloc(C.sizeof_struct_rcl_interfaces__msg__FloatingPointRange * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		FloatingPointRangeTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func FloatingPointRange__Array_to_Go(goSlice []FloatingPointRange, cSlice []CFloatingPointRange) {
	for i := 0; i < len(cSlice); i++ {
		FloatingPointRangeTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func FloatingPointRange__Array_to_C(cSlice []CFloatingPointRange, goSlice []FloatingPointRange) {
	for i := 0; i < len(goSlice); i++ {
		FloatingPointRangeTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
