// Code generated by rclgo-gen. DO NOT EDIT.

package rcl_interfaces_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <rcl_interfaces/msg/integer_range.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("rcl_interfaces/IntegerRange", IntegerRangeTypeSupport)
	typemap.RegisterMessage("rcl_interfaces/msg/IntegerRange", IntegerRangeTypeSupport)
}

type IntegerRange struct {
	FromValue int64 `yaml:"from_value"`// Start value for valid values, inclusive.
	ToValue int64 `yaml:"to_value"`// End value for valid values, inclusive.
	Step uint64 `yaml:"step"`// Size of valid steps between the from and to bound.A step value of zero implies a continuous range of values. Ideally, the stepwould be less than or equal to the distance between the bounds, as well as aneven multiple of the distance between the bounds, but neither are required.If the absolute value of the step is larger than or equal to the distancebetween the two bounds, then the bounds will be the only valid values. e.g. ifthe range is defined as {from_value: 1, to_value: 2, step: 5} then the validvalues will be 1 and 2.If the step is less than the distance between the bounds, but the distance isnot a multiple of the step, then the "to" bound will always be a valid value,e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} thenthe valid values will be 2, 4, and 5.
}

// NewIntegerRange creates a new IntegerRange with default values.
func NewIntegerRange() *IntegerRange {
	self := IntegerRange{}
	self.SetDefaults()
	return &self
}

func (t *IntegerRange) Clone() *IntegerRange {
	c := &IntegerRange{}
	c.FromValue = t.FromValue
	c.ToValue = t.ToValue
	c.Step = t.Step
	return c
}

func (t *IntegerRange) CloneMsg() types.Message {
	return t.Clone()
}

func (t *IntegerRange) SetDefaults() {
	t.FromValue = 0
	t.ToValue = 0
	t.Step = 0
}

func (t *IntegerRange) GetTypeSupport() types.MessageTypeSupport {
	return IntegerRangeTypeSupport
}

// IntegerRangePublisher wraps rclgo.Publisher to provide type safe helper
// functions
type IntegerRangePublisher struct {
	*rclgo.Publisher
}

// NewIntegerRangePublisher creates and returns a new publisher for the
// IntegerRange
func NewIntegerRangePublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*IntegerRangePublisher, error) {
	pub, err := node.NewPublisher(topic_name, IntegerRangeTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &IntegerRangePublisher{pub}, nil
}

func (p *IntegerRangePublisher) Publish(msg *IntegerRange) error {
	return p.Publisher.Publish(msg)
}

// IntegerRangeSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type IntegerRangeSubscription struct {
	*rclgo.Subscription
}

// IntegerRangeSubscriptionCallback type is used to provide a subscription
// handler function for a IntegerRangeSubscription.
type IntegerRangeSubscriptionCallback func(msg *IntegerRange, info *rclgo.MessageInfo, err error)

// NewIntegerRangeSubscription creates and returns a new subscription for the
// IntegerRange
func NewIntegerRangeSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback IntegerRangeSubscriptionCallback) (*IntegerRangeSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg IntegerRange
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, IntegerRangeTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &IntegerRangeSubscription{sub}, nil
}

func (s *IntegerRangeSubscription) TakeMessage(out *IntegerRange) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneIntegerRangeSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneIntegerRangeSlice(dst, src []IntegerRange) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var IntegerRangeTypeSupport types.MessageTypeSupport = _IntegerRangeTypeSupport{}

type _IntegerRangeTypeSupport struct{}

func (t _IntegerRangeTypeSupport) New() types.Message {
	return NewIntegerRange()
}

func (t _IntegerRangeTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.rcl_interfaces__msg__IntegerRange
	return (unsafe.Pointer)(C.rcl_interfaces__msg__IntegerRange__create())
}

func (t _IntegerRangeTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.rcl_interfaces__msg__IntegerRange__destroy((*C.rcl_interfaces__msg__IntegerRange)(pointer_to_free))
}

func (t _IntegerRangeTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*IntegerRange)
	mem := (*C.rcl_interfaces__msg__IntegerRange)(dst)
	mem.from_value = C.int64_t(m.FromValue)
	mem.to_value = C.int64_t(m.ToValue)
	mem.step = C.uint64_t(m.Step)
}

func (t _IntegerRangeTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*IntegerRange)
	mem := (*C.rcl_interfaces__msg__IntegerRange)(ros2_message_buffer)
	m.FromValue = int64(mem.from_value)
	m.ToValue = int64(mem.to_value)
	m.Step = uint64(mem.step)
}

func (t _IntegerRangeTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__rcl_interfaces__msg__IntegerRange())
}

type CIntegerRange = C.rcl_interfaces__msg__IntegerRange
type CIntegerRange__Sequence = C.rcl_interfaces__msg__IntegerRange__Sequence

func IntegerRange__Sequence_to_Go(goSlice *[]IntegerRange, cSlice CIntegerRange__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]IntegerRange, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		IntegerRangeTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func IntegerRange__Sequence_to_C(cSlice *CIntegerRange__Sequence, goSlice []IntegerRange) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.rcl_interfaces__msg__IntegerRange)(C.malloc(C.sizeof_struct_rcl_interfaces__msg__IntegerRange * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		IntegerRangeTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func IntegerRange__Array_to_Go(goSlice []IntegerRange, cSlice []CIntegerRange) {
	for i := 0; i < len(cSlice); i++ {
		IntegerRangeTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func IntegerRange__Array_to_C(cSlice []CIntegerRange, goSlice []IntegerRange) {
	for i := 0; i < len(goSlice); i++ {
		IntegerRangeTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
